var tipuesearch = {"pages": [{'title': 'About', 'text': '修課成員名單  ( 網際程式原始碼 ) \n 課程倉儲:  https://github.com/mdecourse/wcmj2021 \n 課程網頁:  https://mde.tw/wcmj2021 \n 課程 gitter:  https://gitter.im/mdecourse/wcmj2021 \n 分組專題影片回報與討論區: \n https://github.com/mdecourse/wcmj2021/discussions/10 \n 評分: \n 出席 10% \n 個人倉儲與網頁 30% \n 每週網際簡報 html 與 Pdf 報告 60% (含 Youtube 操作影片) \n Repository template:  https://github.com/mdecourse/cmstemplate \n 電腦輔助設計室與協同設計室行事曆 \n 全頁檢視 \n', 'tags': '', 'url': 'About.html'}, {'title': 'WCM', 'text': '何謂網際內容管理 (Web-based Content Management)? \n 在網際進行數位內容資料的管理 \n 何謂網際? \n Web-based \n 何謂 Web? \n World-Wide-Web \n client-browser, server-WWW server \n 何謂數位內容? \n 能夠以數位格式儲存的內容 \n text, equation, plot, images, audio, video, multi-media animation \n 何謂管理? \n 分門別類整理後便於保存, 查找, 分享數位內容 \n 管理的目的為何? \n 紀錄解決問題的過程, 期再次碰到類似問題時可以儘量重用內容 \n 為何大多數內容重用只能是儘量重用? \n 因為環境會變, 工具會變, 整體工作環境系統也會不斷改變 \n 執行網際內容管理需不需要寫程式? \n 不寫, 可以用其他人寫的工具與套件 \n 自己寫, 則可以依照自己或團隊的需求, 量身訂做自己需要的工具或管理系統 \n', 'tags': '', 'url': 'WCM.html'}, {'title': '三道牆理論', 'text': 'KMOLab 所開設課程目的是將擋在機械工程師面前的三道牆, 直接利用課程講授的過程, 一一呈現, 讓大家有及時找出突破這三道障礙的機會, 不僅讓各自的潛能有所發揮, 同時也希望大家能更自在地面對未來的更多挑戰. 這三道牆分別是: \n 理論基礎障礙 實務練習障礙 確立目標障礙 \n 理論基礎障礙 \n 所謂的理論基礎障礙就是技職體系學生在高中階段經常疏忽的英文, 數學與邏輯思考與獲取學問的基本能力. 也就是英文聽說讀寫的基本能力, 數學基本能力與了解如何透過邏輯思考解題, 並且學習如何發問, 如何與人協同合作解決問題的能力. \n http://mde.tw/cad2020/content/W10-W14.html \n 實務練習障礙 \n 第二道牆則是實務練習障礙, 許多人不願意花時間在突破上述第一道障礙的原因, 通常是因為不知道學習這些相對抽象的知識有甚麼用處? 因此, 為了凸顯突破第一道牆的重要性, 就必須要透過實際的課程案例, 讓大家了解一旦能突破第一道牆的障礙後, 養成持續學習這些理論基礎內容之後, 就可以相對用比較有效率的方式解決各種問題. \n 但是這需要學習者付出時間與耐性, 當面對完全陌生議題時, 就必須檢討是否第一道牆仍然卡在自己與解決方案中間. 然後用心不斷思考, 探索與練習之後, 若還是無法解決問題. 就必須要先試著描述問題後再尋求他人的協助. \n 假如能有以上的正確學習態度, 就有機會在面對各種問題時, 持續突破前面的兩道牆, 然後看到自己所追求的第三道牆, 並且此後能夠竭盡全力, 翻閱第三道牆的障礙, 積極達成預定目標. \n http://mde.tw/cad2020/content/HW1.html \n http://mde.tw/cad2020/content/HW2.html \n http://mde.tw/cad2020/content/HW1_SW.html \n https://github.com/KmolYuan/Pyslvs-UI \n 確立目標障礙 \n 你的人生目標是甚麼? \n https://www.ptt.cc/bbs/Tech_Job/M.1588362728.A.14F.html \n', 'tags': '', 'url': '三道牆理論.html'}, {'title': '個人電腦', 'text': '機械工程師由於必須在個人電腦上繪製並顯示 3D 零組件, 因此個人電腦通常需要配備獨立顯示卡, 其基本規格與電競機類似: \n https://www.crucial.tw/articles/for-gamers/the-best-specs-for-a-gaming-pc \n CPU ( Central Processing Unit ) - 中央處理器 \n Intel Processor:  https://en.wikipedia.org/wiki/List_of_Intel_processors \n AMD Processor:  https://en.wikipedia.org/wiki/List_of_AMD_processors \n ARM Architecture:  https://en.wikipedia.org/wiki/ARM_architecture \n Apple Designed Processor:\xa0 https://en.wikipedia.org/wiki/Apple-designed_processors  \u3000 \n FULL HD ( High Definition ) \n Motherboard  主機板 \n RAM ( Random-Access Memory ) \n DDR ( Double Data Rate ) \n 何謂 HDD/SSD? 有何差別? \n 何謂 RPM? \n 何謂 ATA、PATA、與 SATA 連接埠? 有何差別? \n 何謂 Video Card? \n 何謂 fps? \n 何謂 DVI? \n 何謂 HDMI? \n 何謂  LED ? \n 何謂 DirectX? \n 何謂  Watt ? \n 何謂  Power ? \n 何謂 Hz ( Hertz )? \n Computer Monitor \n 何謂 ppi? \n', 'tags': '', 'url': '個人電腦.html'}, {'title': 'Network', 'text': "Understanding bandwidth Bandwidth refers to the data rate that is supported by the network connection or the interfaces that connect to the network. It represents both volume and time, representing the amount of data that can be transmitted between two points in a set period of time. It is usually expressed in terms of bits per second (bps), or sometimes in bytes per second (Bps). Network bandwidth represents the capacity of the network connection, though it's important to understand the distinction between theoretical throughput and real-world results when figuring out the right bandwidth formula for your network. For example, a 1000BASE-T -- which uses unshielded twisted-pair cables -- Gigabit Ethernet (GbE) network can theoretically support 1,000 megabits per second (Mbps), but this level can never really be achieved in practice because of hardware and systems software overhead. One point to consider when thinking about how to calculate bandwidth needs on your network is this: Bandwidth should not be confused with throughput, which refers to speed. While high-bandwidth networks are often fast, that is not always the case. A helpful metaphor when thinking about bandwidth is cars on a highway. A high-bandwidth network is like a six-lane highway that can fit hundreds of cars at any given moment. A low-bandwidth network is like a single-lane road in which one car queues directly behind another. Although the large highway is likely to move vehicles faster, rush-hour traffic can easily bring cars and trucks to a standstill. Or, perhaps, the cars cannot get onto the highway quickly because it's clogged with large delivery trucks that take up a lot of space on the road. Similarly, even a high-bandwidth network can run slowly in the face of problems, such as congestion and bandwidth-hungry applications. These very points make calculating bandwidth requirements a challenge, yet the consequences of getting the bandwidth formula wrong are considerable. If you don't procure enough bandwidth, you all but guarantee the network will run slowly. However, significantly overprovisioning bandwidth can be cost-prohibitive for most enterprises. So, how do you determine the right formula that will meet your bandwidth requirements? The process begins with asking the right questions: What applications are users running, and what is the performance service-level agreement for these applications? I know some network managers who are only concerned with how many users are on a virtual LAN. What you really need to know is what the users will be doing on the network. It's possible that 200 users will cause less of a bottleneck than a group of three users that really beats the heck out of the network because of some funky client-server application or extensive use of a bandwidth-heavy service, like high-definition video conferencing. \n \n 了解  https://www.wireshark.org  的用法, 並藉以提升網路頻寬的使用效能及安全. \n 近端下載 \n http://a.kmol.info:88/Wireshark-win64-3.4.2.exe \n", 'tags': '', 'url': 'Network.html'}, {'title': 'Switch', 'text': 'Not all switches are created equal. \n 來源 \n https://www.cisco.com/c/en/us/products/switches/index.html#~products \n https://www.cisco.com/c/dam/en/us/products/collateral/switches/catalyst-9300-series-switches/nb-06-upgrading-cat-9300-fc-cte-en.pdf \n internally to a switch a specialized hardware is needed to move frames between ports. This specific part can be called backplane (背板) or in some cases we talk of switching fabric (交換結構). When the forwarding capabilities of a backplane or switching fabric are greater then the sum of speeds of all ports (counted twice one for tx and one rx direction) we call the switching fabric non blocking: traffic between a pair of ports is not influenced by what traffic is exchanged on all other ports. The forwarding rate is expressed in packet per seconds and expresses how many packets per second are needed to reach a certain traffic volume (throughpout) Clearly forwarding rate depends on frame size. Ideally a backplane switching fabric should be non blocking for every frame size including the smallest ones (64 bytes in ethernet standard) but in reality most devices can be non blocking for an average size of 400 bytes. bandwidth: the speed of traffic. to convert between forwarding rate and used bandwidth we need to take in account some specific aspects of ethernet: each frame has an 8 byte preamble that is used to allow to potential receiver to synchronize with the signal between two frames a minimum silence interval must exist to allow receiver to discriminate between two frames preamble and inter frame gap counts for 20,2 bytes. So given an iP packet of size N the ethernet frame has size N+18\xa0 (header 14 bytes, FCS 4 byte) but counts as (N+18+20,2)*8 on wire 8 is number of bits in a byte with this kind of calculation using frames of minimum size 64 bytes you need 1488000 frames per second and per direction to fill a GE port. Be also aware that all figures you see sum tx and rx directions so if a switch has 100 M pps capability this accounts for a certain number of GE ports at 1 Gbps full duplex. \n Do not confuse the speed of the stackwise ring with the internal switching fabric of each stack member, they are different: the internal switching fabric should be used for traffic between ports on the same stack member device, the stackwise bandwidth should be used when traffic must flow between ports located on different stack members. Note: this is just my assumption about the implementation of stack, it may be different with the dual ring involved also for traffic between two ports on the same member switch. (total lack of so called local switching capabilities). The stack implements a dual ring topology between the member switches that act as an extension of the individual switching fabrics. The speed of the ring for a stack of only 3750-X (stackwise plus) should be 32 Gbps full duplex that allows for a very good interconnection between member switches, but I agree it is not enough to classify the composite switching fabric as not blocking. On the other hand, only models with 10GE ports can be interconnected at comparable speeds. To make a comparison a C6500 equipped with Sup720 generation route processor provides up to 40 Gbps per slot to/from the switching fabric and some linecards are faster then that ( think of\xa0 WS-6708 or WS-6716 with 8 and 16 tengiga ports respectively). About the forwarding capacity in pps: for a 24 ports device is listed as 65.5 Mbps that accounts for 22 GE ports 1Gbps full duplex with 64 byte frames. \n An original series 3750 (or 3560) fabric is 32 Gbps.\xa0 This is different from the stack ring\'s "32 Gbps" (which is really dual 8 Gbps, duplex). An original series 3750 (or 3560) internal fabric, in theory, is oversubscribed by more than 16 gig ports (i.e. the "G" suffixed original models). The terms non-blocking and blocking, when examining switch fabric isn\'t just sufficient bandwidth capacity to forward all port bandwidths, it\'s whether the fabric\'s architecture will block, or not, forwarding of frames even if there\'s "sufficient" bandwidth. For example, you have three ingress ports.\xa0 Two are sending to one egress port (2:1) and the other is sending to other egress port (1:1).\xa0 If 2:1 congestion on the one egress port delays (or blocks) transmission on the 1:1 egress port, you have HOL (head-of-line) blocking even though the internal fabric\'s bandwidth could support each ingress port sending to a separate egress port (all 1:1). StackWise (and StackWise+), when available, use both ring ports. Original StackWise copies ALL member switch traffic to the stack ring.\xa0 Original StackWise source stack member also removes the traffic it placed on the stack ring. StackWise Plus only places unicast traffic on the stack ring when destination is not a local switch port.\xa0 Additionally, destination switch member removes unicast packets.\xa0 (I.e. StackWise+ uses it\'s ring much more intelligently.\xa0 It also has dual 16 Gbps stack ring ports.\xa0 NB:StackWise+, for the most part, reverts to StackWise operation if there\'s a StackWise only member switch in the stack [good reason not to use such mixed stacks].) Bits per second, is the transmission rate supported by the media.\xa0 So, for example, 100 Mbps allows transmission of 100,000,000 bits per seconds.\xa0 However, transferring actual data, in something like physical segments (e.g. frames) uses some of this capacity for both framing overhead and framing delineation, so useful capacity is less than the often quoted bps rate.\xa0 Useful capacity percentage (of overall rate) also generally decreases as frame size decreases.\xa0 (BTW, similar issue with disk media.\xa0 At least disk capacity isn\'t, generally, quoted for its unformatted capacity any longer.) The 25 Mbps throughput is rated for minimum sized packets.\xa0 Larger packets often allow much higher throughput as the packets per second requirement (for same bandwidth) decreases.\xa0 (Sometimes the vendor will document PPS rates for multiple packet sizes.\xa0 Without such documentation, or your own testing, just knowing documented performance for one packet size you cannot accurately predict a device\'s performance for other packet sizes.) \n 來源 \n Switch backplane bandwidth, switching capacity, packet forwarding rate difference Backplane bandwidth refers to the entire switching capacity of the backplane, switching capacity refers to the switching capacity of the CPU, and packet forwarding refers to the capacity of the three-layer forwarding. First, the backplane bandwidth 1. Switch backplane bandwidth meaning \n The backplane bandwidth of the switch, also called the backplane capacity, is the maximum amount of data that can be handled between the switch interface processor or the interface card and the data bus. The backplane bandwidth marks the total data exchange capacity of the switch, in Gbps. The backplane bandwidth of a typical switch ranges from a few Gbps to hundreds of Gbps. The higher the backplane bandwidth of a switch, the better the ability to process data, but at the same time the design cost will be higher. 2. The internal structure of the switch \n The utilization of backplane bandwidth resources is closely related to the internal structure of the switch. At present, the internal structure of the switch mainly has the following types: \n First, a shared memory structure, which relies on a central switching engine to provide a high-performance connection for a full port, and the core engine checks each input packet to determine a route. This method requires a large memory bandwidth and high management cost. Especially with the increase of the switch port, the price of the central memory will be very high, so the switch core becomes the bottleneck of performance realization; \n the second is the cross bus structure, which can Establish a direct point-to-point connection between ports, which is good for single-point transmission, but not suitable for multi-point transmission; \n the third is a hybrid cross-bus structure, which is a hybrid cross-bus implementation. Its design idea is to integrate The cross bus matrix is divided into small cross matrices connected by a high performance bus. The advantage is that the number of cross-buses is reduced, the cost is reduced, and bus contention is reduced; however, the bus connecting the cross-matrix becomes a new performance bottleneck. 3. Linear non-blocking transmission \n The best performance we can buy for the transfer machine is to require linear non-blocking transmission. How do we investigate whether the backplane bandwidth of a switch is sufficient? How to determine whether the design of the switch you bought is reasonable, and there is a blocking structure design? \n Calculation formula: \n A. The sum of the number of all port capacity X ports should be less than the backplane bandwidth, which can realize full-duplex non-blocking switching, which proves that the switch has the conditions of maximizing data exchange performance. \n B. Full configuration throughput (Mbps) = full configuration GE port number × 1.488 Mpps, wherein the theoretical throughput of a Gigabit port with a packet length of 64 bytes is 1.488 Mpps. For example, a switch with up to 64 Gigabit ports should have a full configuration throughput of 64 x 1.488 Mpps = 95.2 Mpps to ensure non-blocking packet switching when all port line speeds are working. Example: If a switch can provide up to 176 Gigabit ports and the declared throughput is less than 261.8 Mpps (176 x 1.488 Mpps = 261.8), then the user has reason to believe that the switch is designed with a blocking structure. \n For 10 Gigabit Ethernet, the packet forwarding rate of a wire-speed port is 14.88 Mpps. \n For Gigabit Ethernet, the packet forwarding rate of a wire-speed port is 1.488 Mpps. \n For Fast Ethernet, the packet forwarding rate of a wire-speed port is 0.1488 Mpps. \n For OC-12 POS ports, the packet forwarding rate of a line rate port is 1.17 Mpps. \n For the POS port of OC-48, the packet forwarding rate of one line-speed port is 468MppS. \n Therefore, if we can meet the above three conditions, then we say that this switch is truly linear and non-blocking; the back-up rate of the switch is generally: \n Mbps, which refers to the second layer, which is used for the exchange of more than three layers. \n Mpps 4. The backplane bandwidth does not exist in the switch with the fixed port. \n This concept is only possible with modular switches (with scalable slots that can flexibly change the number of ports). Fixed-port switches do not have this concept, and the backplane capacity and switching capacity of fixed-port switches are equal. The backplane bandwidth determines the maximum bandwidth for the connection between each board (including boards that are not yet installed in the expandable slot) and the switching engine. Due to the different architectures of modular switches, backplane bandwidth is not fully effective at representing the true performance of the switch. Fixed port switches do not have the concept of backplane bandwidth. Second, the exchange capacity \n It is the transmission capacity of the core CPU and bus, generally smaller than the backplane bandwidth. H3C low-end LSW switching uses the store-and-forward mode. The size of the switching capacity is determined by the bit width of the buffer (BUFFER) and its bus frequency. That is, the switching capacity = cache bit width * cache bus frequency = 96 * 133 = 12.8 Gbps H3C high-end switch exchange capacity can be equal to twice the total port capacity, total port capacity = 2 * (n * 100Mbps + m * 1000Mbps) ( n: indicates that the switch has n 100M ports, m: indicates that the switch has m 1000M ports. \n 3. The packet forwarding rate forwarding capability is measured by the minimum packet length. For the Ethernet minimum packet is 64BYTE, plus the frame overhead 20BYTE. Therefore, the minimum package is 84BYTE. For a full-duplex 1000Mbps interface to achieve line speed requirements: forwarding capacity = 1000Mbps / ((64 + 20) * 8bit) = 1.488Mpps for a full-duplex 100Mbps interface to achieve line speed requirements: forwarding capacity = 100Mbps / ((64+20)*8bit)=0.149Mpps Unit: Mpps (Million packets per second) This article is from the "Snow Moon Studio" blog, please be sure to keep this source  http://xueyue8.blog.51cto.com/4650249/1765750   How is the backplane bandwidth, switching capacity, and packet forwarding rate of the switch calculated? For the manufacturers, the standard is higher than the line speed forwarding. \n', 'tags': '', 'url': 'Switch.html'}, {'title': 'Topics', 'text': '個人電腦軟體與硬體基本概念 \n 網路基本概念與設定 \n Windows 10 64 位元隨身程式系統 \n http://mde.tw \n cmsimde \n blogger \n Github \n Fossil SCM \n http://fossil.kmol.info \n http://mde.tw/fosgit \n http://fossil.kmol.info/fosgit/doc/trunk/index.html \n https://fossil.kmol.info/fosgit/doc/0f7bf53ab9/content/index.html \n http://jpme.eng.nfu.edu.tw \n \n', 'tags': '', 'url': 'Topics.html'}, {'title': 'Topic 1', 'text': '計算機概論課程回顧 \n 首先必須先了解電腦輔助設計室中的網路設定: \n 由於上課時各電腦採用純 IPv6 協定上網, 因此可以將 IPv4 網路協定勾選移除, 且以 DHCP6 取得 2001:288:6004:17:xxxx 格式的 IPv6 網路位址, 惟需自行設定 DNS 伺服器. 可以選擇機械設計工程系的 DNS 伺服器 2001:288:6004:17::3 或中華電信 DNS 伺服器 2001:b000:168::1 \n \n 接著學習如何利用可攜式 ShareX 錄製電腦操作畫面流程, 存為 mp4 格式後上傳到 @gm 帳號對應的 Youtube. 本課程建議各學員將每週根據課程進度所操作的流程錄製成 mp4 影片嵌入個人的網誌與網頁中. \n \n 接著學習如何利用 @gm 帳號建立分組 Blogger. 完成後各分組的網誌連結如下: \n https://wcmj2021g1.blogspot.com \n https://wcmj2021g2.blogspot.com \n https://wcmj2021g3.blogspot.com \n https://wcmj2021g4.blogspot.com \n https://wcmj2021g5.blogspot.com \n https://wcmj2021g6.blogspot.com \n https://wcmj2021g7.blogspot.com \n \n 各組組長完成分組 Blogger 網誌建立後, 可利用設定選項將各組員設為可在分組網誌發佈文章的協同管理者或協同作者. \n \n 接著學習如何透過 Youtube 影片中分享功能中的嵌入選擇取得特定影片的 iframe 嵌入 html 後, 可將各組員所製作的電腦操作影片嵌入個人網站或分組網誌中. \n \n 每一位學員登入學校配發的 Gmail 帳號後, 至  https://www.blogger.com  建立一個網誌, 並將上學期計算機課程的內容摘要整理為  Blogger  網誌內容. 可以按照每一週的教學內容整理為網誌, 或者根據教學主題內容整理為網誌內容. \n 請問: \n 已知  修課學員名單  ( nfulist 程式碼 ) ( 從教務主機查詢資料 ) 可以取得修課學員名單, 是否可以用於取得各學員的個人  Blogger  連結? \n 採人工方式啟動 Ethercalc 網際表單, 從修課學員名單中複製學號行資料, 然後在  https://gitter.im/mdecourse/wcmj2021  公佈網際表單連結, 讓各學員依照學號填入個人 Blogger 網誌連結後, 再複製資料, 並設法轉為 HTML Anchor 連結. \n 上述流程能不能採更方便的流程進行 (減少人工複製與處理可能產生的錯誤)? \n http://mde.tw/cad2020/content/Ethercalc.html \n https://github.com/audreyt/ethercalc/blob/master/API.md \n https://pypi.org/project/ethercalc-python/ \n http://mde.tw/cd2021/content/Topics.html \n Blogger API  能夠做甚麼? \n 相關技術: \n Python  - 會編寫基本的 Python 程式 \n http://mde.tw/cp2020 \n HTML  - 了解超文件相關標註用法 \n Jascript  - 了解 Javascript 如何與 HTML 結合應用? \n Flask  - 了解如何使用 Flask 網際框架? \n bs4  - 了解如何透過 Python 的 beautifulsoup 模組解讀 HTML 取用網頁上的相關資料? \n AJAX  - 了解 AJAX 如何運作? 如何應用? \n Heroku  - 了解如何將網際程式部署到 Heroku 雲端系統? \n http://mde.tw/cp2020/content/Heroku.html \n http://mde.tw/cp2020/content/scissor-rock-paper.html \n 應該要如何將選課學員的個人  Blogger  網誌連結整理 (嵌入)在這個頁面? \n 2010_Beginning Google Blogger.pdf \n 網際內容管理課程目標: \n 精密機械設計工程師可以利用具版次與歷程管理系統, 長期記錄學習與研究結果. \n 利用網際流程展示產品設計或製造流程 \n http://mde.tw/virtualkossel/ \n 背景知識: \n \xa0英文閱讀能力重不重要? \n 何謂  World Wide Web ? ( 全球資訊網 , 又稱為萬維網) \n 為什麼  https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91  其實就是 https://zh.wikipedia.org/wiki/萬維網 \n html 與 WWW 的關係為何？ \n 為什麼在上列中文版的萬維網說明頁面, 會被標註"此條目翻譯品質不佳"? 英文說明頁為何沒有這樣的問題? \n 電腦軟硬體應用能力重不重要? \n 要將各學員的  Blogger  網誌連結放入這個頁面, 除了手動一一 key in 編輯外, 還有沒有其他較有效率的做法? \n 用  https://ethercalc.net/  按照學號次序取得各學員的  Blogger  網誌連結後, 存成檔案, 然後再編寫程式讀取各學員的網誌連結後, 建立所需的 html 超文件格式內容後, 直接差異本頁面特定位置後存檔. \n 將本網誌設定為可公開編輯的動態網頁模式, 讓各學員自行登入將網誌連結輸入後, 以"協同編輯模式"存檔後進行檢查與整理. (此一方案所得到的結果, 與上列其他方法比較有何優點或缺點?) \n 還有沒有其他更有效率的做法? \n 議題討論: \n 假如一位精密機械工程師只能接收中文資料, 面對"翻譯品質不佳"的萬維網"說明內容, 是否應該有因應對策? \n KMOLab 鼓勵年輕人儘快翻越橫在面前的 三面牆理論 . \n 假如想要利用程式方法解決電腦軟硬體應用過程所碰到的問題? 該具備哪些基本條件? \n 你對電腦與網路的軟硬體配置及應用有多少了解? \n 你是否具備基本的英文閱讀能力? 你能夠不看鍵盤進行英文與中文打字嗎? 我應該要學習哪一種或哪幾種中文輸入法? 或者此後完全使用語音轉文字的方式輸入? \n 截至目前只上過計算機概論, 而且下學期才上計算機程式, 我們有能力現在就開始學習如何寫電腦程式嗎? \n 電腦與網路軟硬體是現代人生活中不可或缺的工具, 只要確認數位方法能夠有效解決問題, 任何人都可以在任一時間點設法透過客製化的軟硬體方案 (自行編寫或修改既有方案) 解決所面臨的問題. \n 了解 Windows 10 64 位元基本操作方式 \n 自行在 Windows 10 64 位元中建立可攜程式環境 (Why?) \n 自行在 Windows 10 64 位元環境中建立 Ubuntu 虛擬 Virtualbox 主機, 或者透過  WSL  了解 Linux 系統應用方法. \n', 'tags': '', 'url': 'Topic 1.html'}, {'title': '主機板', 'text': 'UEFI 觀念與迷思 \n UEFI vs. BIOS \n UEFI 與 BIOS 有甚麼區別? \n 說明為何要以 UEFI 取代 BIOS? \n UEFI v.2.8 Specification.pdf \n Defining the Interface Between the Operating System and Platform Firmware \n 統一可延伸韌體介面 \n 請各組看完上述資料後, 針對 UEFI 與 BIOS 開機流程與架構, 配合實作整理出一份內容摘要. \n \n', 'tags': '', 'url': '主機板.html'}, {'title': 'W2-W3', 'text': '說明與機械設計工程系綜一館八樓電腦輔助設計室電腦網路設定有關的步驟 \n \n demo 如何利用 git 將遠端  https://github.com/mdecourse/wcmj2021  倉儲 git clone --recurse-submodules URL 到近端後, 利用 Python 啟動 cmsimde 網際內容管理系統的動態網站, 加入第三階的 W2 頁面後, 將上一個影片嵌入後, 以 git add, commit 及 push 把改版的內容新增提交推送至 Github 倉儲, 得到改版後的  http://mde.tw/wcmj2021/content/W2.html \n \n 說明如何從  http://a.kmol.info:88  下載可攜程式系統 kmol2021_spring_v3.7z, 利用  https://www.7-zip.org  解開壓縮後, 即可用 start_ipv6.bat 啟動系統, 並示範如何執行 Python 程式. \n \n 說明如何利用  https://github.com/mdecourse/cmstemplate  建立自己的 帳號.github.io 網站 \n \n', 'tags': '', 'url': 'W2-W3.html'}, {'title': 'W4', 'text': '截至目前為止, 我們已經介紹如何利用學校所配發的 @gm 電子郵件帳號建立在  https://www.blogger.com  的 個人網誌 以及 分組網誌 , 也說明如何在  https://github.com/  利用  帳號.github.io  倉儲建立 個人網站 , 接下來將以每組六人為一個單位進行網際內容的閱讀以及整理, 以下為第九週期中考之前, 希望各組完成閱讀, 討論並整理的相關內容: \n \n 與計算機概論與電腦網路有關的內容整理 -  Intro to computer1 ,  2 ,  computer networks , ( ntu ee course ) \n 利用  Brython  學習簡單的 Python 語法. ( 基本程式練習 ) \n \n sort1.py \n # Python program for implementation of Bubble Sort\n# 說明\n\ndef bubbleSort(arr):\n    n = len(arr)\n \n    # Traverse through all array elements\n    for i in range(n-1):\n    # range(n) also work but outer loop will repeat one time more than needed.\n        \n        # Last i elements are already in place\n        for j in range(n-i-1):\n \n            # traverse the array from 0 to n-i-1\n            # Swap if the element found is greater\n            # than the next element\n            if arr[j] > arr[j+1] :\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n       \n        print(str(i+1)+"個已經排好", "共比較"+str(j+1)+"次", arr)\n \n# Driver code to test above\narr = [90, 64, 34, 25, 12, 22, 11, 5, 3]\nprint("original", arr)\nbubbleSort(arr)\n \nprint ("Sorted array is:")\nfor i in range(len(arr)):\n    print ("%d" %arr[i])\n \n 說明如何在 Github 帳號下利用 "帳號.github.io" 倉儲建立網頁. 基本的建置流程為: \n \n 登入 Github 帳號 \n 連線至  https://github.com/mdecourse/cmstemplate  後點擊 Use this template, 以此倉儲內容作為樣板, 所建立的倉儲即可透過 Github Pages 的架構, 產生對應的個人網頁 \n 假如再使用 Brython 可以在網頁中建立一個基本的網際 Python 練習頁面 \n \n \n W10-W17 (若各組分別完成實體與虛擬主機後, 配置 cmstemplate 動靜態網站, 以及 SW, NX, Inventor, 後續可配置以下內容) \n \n 網際內容管理應用 I -  Glowscript  ( Examples ) (2Weeks) \n 網際內容管理應用 II -  Fossil SCM  (2Weeks) \n 與精密機械有關的主題內容整理 -  Robotics  ( Intro2Robotics ,  IntroToRobotics ),  Forward kinematics ,  Robot precision evolves  (2Weeks) \n 基本參數 3D 設計繪圖 ( Solvespace  and  CoppeliaSim ) 並利用 Python 控制 robot ( Python 3.9  and  RoboDK ). (2Weeks) \n \n 參考資料: \n 假如想要自行開發類似 RobotDK 的模擬套件 (具備 Python, OpenGL, PyQt5 與  Robotics  相關知識): \n https://github.com/mdecourse/RobotSimulator \n http://pyopengl.sourceforge.net/context/tutorials/index.html \n Beginning PyQt ebook \n https://www.glprogramming.com/red/ \n PyOpenGL.pdf \n learningopengl.pdf \n https://stackabuse.com/advanced-opengl-in-python-with-pygame-and-pyopengl/ \n https://docs.huihoo.com/pyopengl/python-for-opengl.html \n https://robodk.com/blog/robot-euler-angles/ \n RoboDK API examples:  https://robodk.com/doc/en/PythonAPI/examples.html \n 2015_Inverse Kinematic Analysis of Robot Manipulators.pdf \n https://github.com/mdecourse/Pick-And-Place \n', 'tags': '', 'url': 'W4.html'}, {'title': 'Python', 'text': 'Python 語法 \n 由於 Github Pages 不允許伺服 __init__.py 檔案, 因此下列範例中需要導入 ggame 的部分, 將無法在 Github Pages 網站中執行. \n Python 3 官方教材:  https://docs.python.org/3/index.html \n Python tutorial:  https://docs.python.org/3/tutorial/index.html  (英文) \n Python 教學:  https://python-doc-tw.github.io/tutorial/index.html \n 網頁上的 Python - Brython:  https://www.brython.info/static_doc/en/intro.html  (解譯式) \n 網頁上的 Python GUI- Flexx:  https://flexx.readthedocs.io/en/stable/  (轉譯式) \n 開放電子書: \n Python 教程  (中文) \n Python 入門指南  (中文) \n how-to-code-in-python.pdf  (英文) \n https://www.py4e.com/book.php  (英文與小部分完成中文翻譯) \n \n \n \n  for ggame  \n \n \n \n \n \n  Cango 程式庫  \n \n \n \n  for Konva 程式庫  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n 開始練習 print() 用法, 並著手建立函式 \n  印出版次與關鍵字程式  \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .py   \n Run   Output   清除輸出區 清除繪圖區 Reload \n \n \n \n  ****************************** keyword start  \n \n \n  ****************************** keyword end  \n  ***************************** slide ex1 start  \n \n \n \n  ***************************** slide ex1 end  \n  ***************************** slide ex2 start  \n \n \n \n  ***************************** slide ex2 end  \n  ***************************** slide ex3 start  \n \n \n \n  ***************************** slide ex3 end  \n  ***************************** slide ex4 start  \n \n \n \n  ***************************** slide ex4 end  \n  line drawing start  \n \n \n \n  line drawing ends  \n \n  flag ex start  \n \n \n \n  flag ex ends  \n \n  bunny start  \n \n \n \n  bunny ends  \n \n  clear canvas start  \n \n \n \n  clear canvas ends  \n \n  cango spur gears start  \n \n \n \n  cango spur gears ends  \n \n  temp convert start  \n \n \n \n  temp convert ends  \n \n  forloop start  \n \n \n \n  forloop ends  \n \n  guess start  \n \n \n \n  guess ends  \n \n  autoguess start  \n \n \n \n  autoguess ends  \n \n  lottery start  \n \n \n \n  lottery ends  \n \n  台灣威力彩 start  \n \n \n \n  台灣威力彩 ends  \n \n  bezier starts  \n \n \n \n  bezier ends  \n \n  turtle1 starts  \n \n \n \n  turtle1 ends  \n \n  turtle2 starts  \n \n \n \n  turtle2 ends  \n \n  turtle3 starts  \n \n \n \n  turtle3 ends  \n \n  turtle4 starts  \n \n \n \n  turtle4 ends  \n \n  turtle5 starts  \n \n \n \n  turtle5 ends  \n \n  turtle6 starts  \n \n \n \n  turtle6 ends  \n \n  turtle7 starts  \n \n \n \n  turtle7 ends  \n \n  turtle8 starts  \n \n \n \n  turtle8 ends  \n \n  konva1 starts  \n \n \n \n  konva1 ends  \n \n  ycqsort starts  \n \n \n \n  ycqsort ends  \n \n  ball starts  \n \n \n \n  ball ends  \n  ****************************** bubble sort start  \n \n \n  ****************************** bubble sort end  \n Keyword Bubble Sort Ex1 Ex2 Ex3 Ex4 Ex5 Guess Autoguess 大樂透 威力彩 Temp Draw Flag Bezier Turtle1 Turtle2 Turtle3 Turtle4 Turtle5 Turtle6 Turtle7 Turtle8 Konva1 Bunny Ball Spur Ycqsort Clear \n 參考資料: \n turtle_intro.pdf \n turtle_intro2.pdf \n 其他擷取程式的方式:  http://mde.tw/2017springvcp/blog/web-based-python.html \n Qt for Python \n https://www.qt.io/qt-for-python \n https://build-system.fman.io/python-qt-tutorial \n https://build-system.fman.io/pyqt-exe-creation/ \n https://github.com/mherrmann/fbs-tutorial \n https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened \n QML 與 Flutter \n https://paulhammant.com/2016/11/15/qmls-squandered-opportunity/ \xa0中所提到 QML 的弱點在於將 .qml 與 .c++ 或 .py\xa0 分開的問題, Google 總算在 Flutter 適度解決了此一瓶頸. \n 但是 QML 加上 Qt for Python 仍不失為一個好了 Desktop GUI 開發框架. \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Python.html'}, {'title': 'W5', 'text': '網際內容管理的使用建議: \n \n 在雲端上只存放與個人或團隊專業有關的內容 (以學號作為 identity, 除了  Linkedin  外, 不要使用本名) \n 不要將個人生活有關的圖文放到網際空間 (不要使用臉書, 不要使用其他任何雲端社群服務擺放任何個人資料) \n 儘量使用瀏覽器查找資料, 每次使用後要刪除暫存檔, 避免使用手機上綁定實名制的 Apps \n \n 這個禮拜開始至 W9, 各小組要將 W1-W4 的教學影片加以整理, 讓每位組員都能在 Blogger 整理自己過去一個多學期的課程學習內容, 以網際內容管理架構, 可攜程式系統及 Github 倉儲與網頁的模式存放內容. \n 網際內容管理學習 Check List: \n \n 是否已經建立個人 Blogger? \n 是否會使用 Blogger, 新增協同著作者? \n 是否會在 Blogger 中使用各種 HTML 標註, 包括加入 Python 程式碼, 嵌入影片檔案等? \n 是否會利用  https://github.com/mdecourse/cmstemplate  建立個人網頁? \n 是否會在個人網站上嵌入網際 Python ( Brython ) 程式環境? \n 是否已經了解所謂的 Bubble Sort Python 程式? \n 是否已經會使用 SSH 將改版資料 push 到 Github? \n 各組是否已經找到想要研究的網際內容管理相關的分組專案題目? \n \n 2008_Organizing and Managing Personal Electronic Files- A Mechanical Engineer’s Perspective.pdf \n how-to-code-in-python.pdf \n 2018_中國區塊鍊產業白皮書.pdf \n 2019-08專題報告-區塊鏈plus時代的社經變革與創新思維.pdf \n 2020年中小企業白皮書(全)_v1.pdf \n 創意台灣 2020 政策白皮書.pdf \n Blockchain_for_dummies.pdf \n ComputerNetworks_936_pages.pdf \n 2030 台灣科技願景: \n taiwan_2030_tech_vision.pdf \n', 'tags': '', 'url': 'W5.html'}, {'title': 'W7', 'text': '本週起將請各分組根據說明, 利用分組 Blogger 與個人 Github Pages 網站整理 分組專題 上的內容. 各組將在 W9 利用網際 Reveal 簡報, 以 ShareX 錄製分組專題報告影片. 相關分組報告影片可參考協同產品設計實習  Stage1 簡報影片 . \n 以下則是 W7 的教學內容: \n Course notes: \n Introduction to robotics \n http://hades.mech.northwestern.edu/index.php/Modern_Robotics \n Open Access related ebooks: \n 2018_Book_ControlTheoryTutorial.pdf  ( 開放授權 電子書) \n 2021_Book_Cyber-PhysicalSystemsAModel-Ba.pdf  ( 開放授權 電子書) \n Springer Open Access ebooks \n Featured Open Access Journals in Engineering \n Featured Open Access Journals in Mechanical Engineering & Mechanics \n Industrial robot off-line simulation 套件下載: \n https://www.parallemic.org/RoKiSim.html  (自由軟體 - no support freeware) \n http://a.kmol.info:88/robodk522_kmol.7z  (無存檔功能的 試用版  - trial version without save function) \n 可攜系統下載: \n http://a.kmol.info:88/kmol2021_spring_v4_robodk.7z  (783 MB) Python 3.9.2 與 RoboDK \n http://a.kmol.info:88/kmol2021_spring_v4_robodk_webots.7z  (2.35 GB) Python 3.9.2 ( 自由開源套件 ),  RoboDK  (無存檔功能的 試用版 ) 與  Webots  ( 自由開源套件 ) \n \n \n ABB irb4600 robot \n IRB4600_ROB0109EN_J_datasheet-Rev.L.pdf \n IRB4600_product_manual_spare_parts.pdf \n https://cyberbotics.com/doc/guide/irb4600-40 \n Coppeliasim ABB IRB4600-40-255 model \n ABB IRB4600 Inventor model \n \n 以下利用 Python 3.9.2 程式控制 Robodk 5.2.2 版本中的 ABB IRB4600 機械手臂. \n \n 控制程式: \n welding_ex1.py  (from  https://robodk.com/doc/en/PythonAPI/examples.html ) \n # ref: https://robodk.com/doc/en/PythonAPI/examples.html\n\n\'\'\'\n[     1.000000,     0.000000,     0.000000,    30.000000 ;\n      0.000000,    -1.000000,    -0.000000,    50.000000 ;\n      0.000000,     0.000000,    -1.000000,    50.000000 ;\n      0.000000,     0.000000,     0.000000,     1.000000 ];\n\n\'\'\'\n\n# This macro shows an example to draw a polygon of radius R and n_sides vertices using the RoboDK API for Python\nfrom robolink import *    # API to communicate with RoboDK for simulation and offline/online programming\nfrom robodk import *      # Robotics toolbox for industrial robots\n\n# Any interaction with RoboDK must be done through RDK:\nRDK = Robolink()\n\n# New versions of RoboDK automatically add the current folder to the path (after 4.2.2)\npath_stationfile = RDK.getParam(\'PATH_OPENSTATION\')\n# get the robot, frame and tool objects\nrobot = RDK.ItemUserPick(\'\', ITEM_TYPE_ROBOT)\n    \n# get the current position of the TCP with respect to the reference frame:\n# (4x4 matrix representing position and orientation)\ntarget_ref = robot.Pose()\npos_ref = target_ref.Pos()\nprint("Drawing a polygon around the target: ")\nprint(Pose_2_TxyzRxyz(target_ref))\n\n# move the robot to the first point:\nrobot.MoveJ(target_ref)\n\n# It is important to provide the reference frame and the tool frames when generating programs offline\nrobot.setPoseFrame(robot.PoseFrame())\nrobot.setPoseTool(robot.PoseTool())\nrobot.setZoneData(10) # Set the rounding parameter (Also known as: CNT, APO/C_DIS, ZoneData, Blending radius, cornering, ...)\nrobot.setSpeed(200) # Set linear speed in mm/s\n\n# Set the number of sides of the polygon:\nn_sides = 6\nR = 300\n\n# make a hexagon around reference target:\nfor i in range(n_sides+1):\n    ang = i*2*pi/n_sides #angle: 0, 60, 120, ...\n\n    #-----------------------------\n    # Movement relative to the reference frame\n    # Create a copy of the target\n    target_i = Mat(target_ref)\n    pos_i = target_i.Pos()\n    pos_i[0] = pos_i[0] + R*cos(ang)\n    pos_i[1] = pos_i[1] + R*sin(ang)\n    target_i.setPos(pos_i)\n    print("Moving to target %i: angle %.1f" % (i, ang*180/pi))\n    print(str(Pose_2_TxyzRxyz(target_i)))\n    robot.MoveL(target_i)\n\n    #-----------------------------\n    # Post multiply: relative to the tool\n    #target_i = target_ref * rotz(ang) * transl(R,0,0) * rotz(-ang)\n    #robot.MoveL(target_i)\n\n# move back to the center, then home:\nrobot.MoveL(target_ref)\n\nprint(\'Done\') \n', 'tags': '', 'url': 'W7.html'}, {'title': 'Call for Code', 'text': '參賽發想:  https://heroku5.github.io/taiwan-no1 \n 近端動態網站編輯: \n \n Heroku 同步網站 app 部署: \n \n RedHat PHP App build: \n \n Technology: \n Python and iot: \n https://github.com/IBM-Cloud/python-iot-raspberry-pi \n Python and SQL: \n https://github.com/IBM-Cloud/sql-query-clients \n https://github.com/IBM-Cloud/github-traffic-stats \n Flutter and Flask: \n https://github.com/mohammedhashim44/Flutter-Flask-Login \n Flutter and Raspberry Pi: \n https://github.com/ardera/flutter-pi \n https://www.ansible.com/ \n https://github.com/IBM-Cloud/clouddatabases-redis-helloworld-python \n Bluemix: \n https://blog.cavedu.com/2016/05/15/ibm-bluemix-%E7%AC%AC%E9%9B%B6%E7%AB%A0-ibm-bluemix-%E4%BB%8B%E7%B4%B9/ \n 2021.03.24 \n 以下為新聞稿: \n \n 近幾年，全球人類面臨前所未有的生存危機， 極端氣候導致的天災更加頻繁 ，從 2020 年更有新冠肺炎在全球肆虐，顛覆所有人的生活方式，也重組了商業模式。IBM 一直致力於 環境永續與災害預防 ，自 2018 年起攜手 Call for Code 組織、聯合國與 Linux 教育基金會，舉行「Call for Code Challenge 全球開發者大賽」。此競賽號召全球開發者利用 IBM 提供的免費資源與開放數據，聯合組隊，提交針對因應氣候變遷、水資源和打擊飢荒的解決方案。 今年更首度推出「Call for Code P-TECH Challenge」，全球 16 個國家與地區未滿 18 歲的 P-TECH 教育模式學生，將組隊貢獻他們的 STEM 專長，化身開發人員，呼應 IBM 的號召，一同解決攸關人類永續生存的議題！在台灣，來自台北科技大學、高雄科技大學、虎尾科技大學與仁德醫專四所 P-TECH 學校學生也將組隊參賽，甚至組織跨校、跨區的團隊，與來自全球 16 國的 P-TECH 學生同台競技，一同實踐科技向善的精神！ 「Call for Code P-TECH Challenge」 考驗 P-TECH 學生創新能力、技術力與團隊合作能力 IBM 自 2011 年推動 P-TECH 教育模式（Pathways in Technology Early College High Schools）以來，一直致力於人才培育、串連在地產業與國際資源，為學生們規劃技能與職涯藍圖，以期幫助學生培養職場所需軟硬實力與數位技能，未來可順利接軌職場。基於希望學生運用所學與發揮團隊合作，一起為社會作出有正向積極的貢獻，IBM 今年首次推出「Call for Code P-TECH Challenge」，P-TECH 學生將以「氣候變遷」或「新冠肺炎」作為挑戰主軸，從現在至 6 月底，參賽學生將在設計思考工作坊中，進行主題發想、收斂概念、制訂行動計畫，運用 IBM 所提供的開放數據與模組進行程式編碼（如 Red Hat OpenShift、IBM Cloud、IBM Watson、IBM Blockchain、來自 IBM Weather Company 的大氣資料），向挑戰賽導師諮詢技術內容，並在 6 月底前舉行的 48 小時線上駭客松後提交最終解決方案。全球優勝團隊除了豐厚獎品外，將可擁有額外 4 週時間繼續發展專案並參與項目開發，並將專案引薦給 IBM 高階主管！ \n 兩岸三地啟動 「Call for Code P-TECH Challenge」 「Call for Code P-TECH Challenge」已在這兩週陸續於兩岸三地正式啟動。在 3/23、3/24 的台灣啟動大會上，不少學生表示期望透過與不同學校、文化背景的成員合作，擦出新火花。臺北科技大學智慧自動化工程科二年級的林宏信同學表示，「雖然可能有語言問題和地理距離，但能運用科技軟體輔助溝通，也是新的一種學習體驗」，而其他同學也對於跨校、跨區組隊和交流躍躍欲試。 身為 2019 年 IBM Developer 倡議者也是 P-TECH 導師的 IBM 大中華軟體研發中心軟體工程師鍾純勝（Vincent Chung）不但親自在啟動大會上為學生說明 IBM 的技術工具和應用外，也鼓勵學生，「選題跟創意發想往往是最耗時、困難的地方，但通常確立有興趣的領域以及想解決的問題後，整個主題及實作內容將會明朗化。只要能懂得使用 IBM 提供的應用程式與服務，不需要非常高的技術門檻，也可以完成很有意義的服務與解決方案。」作為本賽事的倡議者，Vincent 將在賽事期間協助同學認識 IBM 開發者資源，期待看到參賽同學透過創意發想，還有國際舞台的同台競技。不但可以累積寶貴的團隊合作與跨文化學習經驗，也打造出屬於自己、具有應用價值並且可以解決人類生存問題的解決方案。 \n \n https://callforcode.org/global-challenge/ \n What is the Call for Code Global Challenge? In the Call for Code Global Challenge, you can join the fight against climate change by building and deploying open source solutions in the cloud. By participating, you’ll build critical skills for yourself and your teams and deploy solutions to help communities across the globe. Built on open source principles, the Call for Code Global Challenge asks developers and problem solvers to form teams and develop solutions that address specific problems in unique, clearly demonstrable ways. The most successful solutions are those scoped to have the greatest community impact with the smallest technological footprint. Last year’s winner Agrolly is a perfect example, with its mobile application to help small farmers better understand what to plant, based on weather patterns and crop characteristics. \n Three global focus areas According to the United Nations, “The impacts of climate change are global in scope and unprecedented in scale. Without drastic action today, adapting to these impacts in the future will be more difficult and costly.” Given the far-reaching and devastating effects of climate change, we have divided the 2021 Global Challenge into three sub-themes: \n What is the problem? Worldwide consumption and production drives the global economy, yet the current use of natural resources is unsustainable. The global material footprint rose nearly 18 percent from\u202f73\u202fbillion metric tons in 2010 to 85.9 billion metric tons in 2017, the UN reports.\xa0 That’s why Sustainable Development Goal 12 aims to achieve economic growth, sustainable development, and reduce our ecological footprint by changing the way we produce and consume goods and resources. \n How can technology solve the problem? Technology can help in many ways, from recommendations on energy efficiency to highlighting the carbon footprint of online purchases. The goal is to take into account all phases of resource use to do more and better with less. \n The idea One of the more pressing challenges in addressing waste and shifting to a more circular economy is the increasing complexity of products.\xa0 Electronics are getting smaller and more sophisticated, making recovery and reuse of materials challenging. Product designers should consider how to create products with end-of-life in mind, by reducing the number of components, for example. Communities could benefit from developing infrastructure, policies, and systems to support repair, reuse, and recycling. To encourage this change, we propose creating a transparent and trustworthy platform for trading resources and knowledge, as well as providing access to a community of experts. This platform will enable producers and consumers to build and buy products in a sustainable way for our society — by reducing waste, increasing the use of recycled materials, and improving the overall repairability of products. The platform would support the two parties supporting sustainable production with recycled materials:  \xa0\xa0\xa0 A producer or a manufacturer who can find and compare price, quality, and carbon impact of recycled materials while learning about best practices for recyclable processing through a trustworthy, real-time trading platform \n \xa0\xa0\xa0 A recycled material supplier who can sell recycled resources directly to producers through a marketplace at competitive rates \n \n \n \n The user interacts with a web application for the marketplace. \n The React app communicates with the back-end APIs. \n The Fastify back end handles data requested by the web app and exposes some public endpoints for material market data through a RESTful API. \n The back end queries Watson Discovery for updated information on materials. \n Discovery manages a collection of recycled and non-recycled material information, such as average prices, carbon impact, and quality. Discovery enriches the data with natural language processing so that it can be more easily indexed. \n Discovery crawls public websites for updates on current material information. \n The back end stores and retrieves information on material that is provided by users in an IBM Cloudant NoSQL database. \n A Kubernetes cluster is used for a scalable, flexible, modern containerized environment. \n New Relic provides Full-Stack Observability and monitoring within the Kubernetes environment \n \n \n \n', 'tags': '', 'url': 'Call for Code.html'}, {'title': 'W8', 'text': "主題一: \n 利用  Leo Editor  編輯  reveal.js  網際簡報. \n 在可攜系統的命令列視窗中輸入 leo, 即可開啟 Leo Editor. 若無法順利開啟 Leo Editor 而且進入視窗表單輸入迴圈, 則可在啟動的 home 目錄下建立一個 .leo 目錄, 且在目錄中建立一個純文字檔案 .leoID.txt 內容為任何字串 (可以使用 leo), 之後再重新啟動可攜系統後, 在命令視窗中輸入 leo 就可以啟動 Leo Editor. \n Leo Editor 基本操作: \n Ctrl + i : insert node (insert) \n Ctrl + r : node 往右移動 (right) \n Ctrl + l : node 往左移動 (left) \n Ctrl + u: node 往上移動 (up) \n Ctrl + d : node 往下移動 (down) \n @edit 節點編輯指令 \n @clean 節點含下屬編輯指令 \n Leo Editor 遞迴導入外部程式碼節點程式: \n c.recursiveImport(\n    dir_ = r'./',\n    # use @clean to parse the associated files\n    kind = '@clean',\n    # if save_at_file = True, @@ will use to protect the source codes\n    safe_at_file = False,\n    theTypes = ['.py']\n) \n recursiveImport 使用案例: \n https://github.com/mdecourse/RobotSimulator  採用 Python 程式語言開發, 使用者可以在開發目錄中建立一個 Leo Editor 專案擋, 並將上述遞迴節點指令輸入後, 以 Ctrl + b 要求執行後, 便可將程式碼納入 Leo Editor 節點架構中. \n CMSiMDE 網際內容管理系統中內含 reveal.js, 其 .leo 檔案位於 config/reveal.leo, 利用 Leo Editor 開啟後, 可以編輯各 slide 內容. slide 1 - slide 31 代表各種不同簡報內容, 各分組可以自行取捨編輯後在靜態網頁中的 Home -reveal 下拉式功能表中開啟. \n WCMJ2021 reveal.js 簡報:  https://mde.tw/wcmj2021/reveal/ \n 主題二: \n Robotics and Automation \n https://www.epfl.ch  ( 瑞士洛桑聯邦理工學院 ) \n Automated Driving 電子書 \n Honda level 3 news  ( Honda Legend ) \n distributed_intelligent_systems.pdf \n Sensing, Action, and Control in Mobile Robotics.pdf \n Localization Methods for Mobile Robots.pdf \n Localization Methods and an Introduction to Collective Movements.pdf \n Collective Movements in Multi-Robot Systems.pdf \n Multi-Level Modeling Methods for Swarm Robotic Systems.pdf \n \n 開源套件: \n Webots: \n The Webots project started in 1996, initially developed by Dr. Olivier Michel at the Swiss Federal Institute of Technology ( EPFL ) in Lausanne, Switzerland and then from 1998 by Cyberbotics Ltd.  2018 年底 Webots 決定開源 \n https://github.com/cyberbotics/webots \n https://github.com/mdecourse/webots_docs \n https://cyberbotics.com/doc/guide/ure \n Interview:  http://lis2.epfl.ch/resources/podcast/2007/01/olivier-michel-robot-simulation-as.html \n \n \n FEM: \n https://github.com/Range-Software/range3 \n https://gitlab.com/akantu \xa0 \n https://www.epfl.ch/labs/lsms/wp-content/uploads/2018/10/akantu_ug_v2.3.pdf \n", 'tags': '', 'url': 'W8.html'}, {'title': 'Hybrid System', 'text': '當使用下列 start_ipv6.bat 批次檔案啟動隨身系統時, 因為部分系統檔案放在 C:\\, 導致原先採用 Y:\\Python39\\python.exe 或 Y:\\Python39\\pythonw.exe 設定的程式無法順利執行, 其中包括 pip (位於 Python39\\Scripts), SciTE 與 Leo Editor. 因應的方式就是要將這些包含絕對目錄設定的內容, 改為採用相對目錄執行 Python. \n 以 SciTE 中的 python.properties 為例, 必須將原先: \n if PLAT_WIN\n    #python.command=pyw\n    python.command=y:\\python39\\pythonw.exe \n 的設定改為: \n if PLAT_WIN\n\t#python.command=pyw\n\tpython.command=pythonw.exe \n 至於 pip.exe 與 leo.exe (位於 Python39/Scripts) 則必須要從 C: 複製一份到 Hybrid 隨身系統的 Y:\\, 並且利用  https://mh-nexus.de/en/hxd/  將 pip.exe 中的\xa0y:\\python\\python.exe 改為 python.exe, 以及將 leo.exe 中的 y:\\python\\pythonw.exe 改為 pythonw.exe. \n 經過兩項修改, Hybrid 可攜隨身系統才能正確利用 SciTE 執行 Python 程式, 並且在命令列中以 pip 進行模組安裝, 以 leo 開啟 Leo Editor. \n start_ipv6.bat \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\nset Local=C:\\kmol2021_spring_v3\\data\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_ipv6\nset HomeDrive=%Disk%:\\home_ipv6\nset Home=%Disk%:\\home_ipv6\nset USERPROFILE=%Disk%:\\home_ipv6\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Local%\\Python39\\DLLs;%Local%\\Python39\\Lib;%Local%\\Python39\\Lib\\site-packages;\n\nset PYTHONHOME=%Local%\\Python39\n\nset GIT_SSH=%Disk%:\\putty\\plink.exe\n\nREM 設定跟 Python 有關的命令搜尋路徑\nset path_python=%Local%\\Python39;%Local%\\Python39\\Scripts;\nset path_portablegit=%Local%\\Portablegit\\bin;\nset path_heroku=%Local%\\heroku\\bin;\nREM for heroku login\nset HTTP_PROXY=http://[2001:288:6004:17::53]:3128\nset HTTPS_PROXY=http://[2001:288:6004:17::53]:3128\n\npath=%Disk%:;%path_python%;%path_portablegit%;%path_heroku%;%path%;\n\nREM ref: https://drive.google.com/file/d/1S0XYN-1MKxo0KFYxs0pFTcTrr8NL4n1b/view\n\nREGEDIT.EXE /S %Disk%:\\putty_github_com.reg;\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Disk%:\\wScite\\SciTE.exe\nstart /MIN %Disk%:\\wScite\\SciTE.exe\n\nExit \n \n', 'tags': '', 'url': 'Hybrid System.html'}, {'title': 'W9', 'text': '期中考週流程: \n \n 利用 ::17 開啟 Ethercalc 表單, 收集各班學員課程期望分數, 將期中期望成績送至教務主機. \n 此一 W1-W9 各學員的期望成績, 將與學員的個人與分組倉儲內容進行比較後, 會反應至學員的期末學期成績中, 若實際評量結果與學員期望成績產生一定差距, 將酌予加減各學員應得之課程學期成績. \n 各分組進行 6-12 分鐘 (每一組員簡報時間至多 2 分鐘) 的期中網際簡報, 主要說明各組員 W1-W8 所完成的網站內容, 並透過 ShareX 錄製簡報影片 (簡報前後按下 Shift + PrintScreen, 並採全畫面錄影), 之後會將各組簡報影片送到 GDrive 以供參考. \n \n 分組簡報影片 \n', 'tags': '', 'url': 'W9.html'}, {'title': 'W10', 'text': '分組專題影片回報與討論區: \n https://github.com/mdecourse/wcmj2021/discussions/10   \n 五專網際內容管理課程下半學期的主題如下: \n W10 將進行下列事項: \n \n 根據 選課成員名單  ( 原始碼 ), 共有 43 位成員, 將以每 6 人一組進行分組專題, 而最後一組則有 7 名組員. \n W10 將以  Ethercalc  取各組員 Github 帳號, 從而建立各組分組網站與組員網站連結 (含倉儲連結) \n 說明  W8  -  Leo Editor  在程式開發流程的應用 + 智動化未來與機電資整合產品開發 (W10 課程內容) \n \n 其餘各週除了說明  Fossil SCM  的應用外, 將介紹如何利用  Leo Editor  建立各組員網站下的  Pelican Blog , 並設法透過程式方法與先前所建立的  Blogger  網誌內容同步. \n W11 - W17 將在課程時段與每週四 (19:00-21:00 實習時段) 進行下列分組專題: \n 選擇 三組執行 主機板 分組專題  ( 實體電腦安裝  - 工作站室選擇 3 台電腦 + 500 GB 硬碟 分別安裝一台 Windows 10, 一台 Ubuntu 20.04 Server, 一台 Ubuntu 20.04 Desktop) 操作系統. \n 三台實體主機分別在 IPv6 網路環境下, 配置可攜程式環境或安裝可啟動 cmstermplate 動態或靜態伺服器的程式環境, 同時安裝配置 Fossil SCM:  https://fossil-scm.org . \n 使用者可以在 Windows 10 環境中以遠端桌面對其他 Windows 10 或 Ubuntu 20.04 X-Windows 進行遠端操控. \n 使用者可以在 Windows 10 環境, 以 ssh 連線至 Ubuntu 20.04 伺服器, 啟動自行架構的 cmstemplate 動態或靜態網際伺服器, 進行動態網際內容管理或檢視靜態網站. \n 選擇 三組執行虛擬主機專題  (   Virtualbox  主機安裝  - 分別在電腦輔助設計室中的三台電腦中 Virtualbox 環境安裝一台˙ Windows 10, 一台 Ubuntu 20.04 Server, 一台 Ubuntu 20.04 Desktop 操作系統. \n 三台虛擬主機分別在 IPv6 網路環境下以 NAT, Host Only 與 Bridged 網卡設定, 與其他實體主機或虛擬主機在網際介面下, 啟動 cmstermplate 動態或靜態伺服器, 同時安裝配置 Fossil SCM:  https://fossil-scm.org . \n 選擇 一組執行  Topic2  分組專題 , 可在電腦輔助設計室中安裝配置學校所提供的  Solidworks, NX12 與 Inventor . \n W17 將利用  Ethercalc  取各學員的課程期望成績. \n W18 將進行各組期末專題網際簡報: \n 各分組在 W11-W17 週專題執行過程, 必須根據所完成的進度, 將內容逐步放入各組員與分組網站中. \n 專題執行期間, 各分組每週必須進行 2-3 分鐘的分組簡報錄影. \n 期末考週各分組必須進行 10 分鐘整的分組簡報錄影.', 'tags': '', 'url': 'W10.html'}, {'title': 'Topic2', 'text': '學校與系上所提供的軟體套件安裝介紹 \n Windows 10 \n 校園軟體 \n 設計與分析套件: \n 輔助工具 \n 校園下載 以下連結必須在校園網路、使用學校代理主機或 vpn 模式下才可下載 AutoDesk PDSU  (Product Design Suite Ultimate edition) 包含: Autodesk Inventor Professional AutoCAD Mechanical AutoCAD Electrical AutoCAD Navisworks Simulate AutoCAD Raster Design Autodesk Recap Autodesk Vault Basic Autodesk Fusion 360 Navisworks Manage AutoDesk 安裝教學.pdf 官方網站下載  希望在任何地方使用,可以從  https://www.autodesk.com/education/free-software/inventor-professional  , 以 @gm 電子郵箱登錄且認證後下載, 取得三年免費使用授權. 允許同時安裝在筆電與桌上型電腦共兩套. 建議安裝流程 利用學校配發的電子郵箱, 連結至  https://www.autodesk.com/education/free-software/inventor-professional  , 登記帳號, 驗證 email 後, 取得 AutoDesk Inventor Professional 版本 2019 的 Serial Number 後, 從學校網站中下載  AutoDesk PDSU , 安裝後, 利用前述所取得的序號啟動 AutoDesk Inventor Professional 2019, 之後就可以在任何地方上網使用. \n 只要是校內 IP 就可以下載, 無需使用 vpn. https://software.nfu.edu.tw/Developer/Visual%20Studio/tw/Visual_Studio_Pro_2019.zip   https://software.nfu.edu.tw/Developer/Visual%20Studio/tw/Visual_Studio_Pro_2017.zip   https://software.nfu.edu.tw/Developer/Visual%20Studio/tw/Visual_Studio_Pro_2015.zip   https://software.nfu.edu.tw/Developer/Visual%20Studio/en/Visual_Studio_Pro_2015.zip   https://software.nfu.edu.tw/Windows/tw/Win10_1909_64BIT_CH.ISO https://software.nfu.edu.tw/KMS/windows_kms.bat   https://software.nfu.edu.tw/Office/tw/Office_Pro_Plus_2016_64Ch.iso https://software.nfu.edu.tw/KMS/Office_2016_KMS.bat \n https://software.nfu.edu.tw/Autodesk/autodesk.iso   https://software.nfu.edu.tw/files/AUTODESK%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8.pdf   2001:288:6004:1::115 \n', 'tags': '', 'url': 'Topic2.html'}, {'title': 'W12', 'text': '學會利用 OBS + Youtube 直播電腦桌面操作過程: \n OBS: 選擇可攜版本  https://portableapps.com/apps/music_video/obs-studio-portable \n Youtube: 利用 @gm 帳號登入後連線至  https://www.youtube.com/ \n 注意瀏覽器代理主機設定要讓 youtube.com 直接透過 IPv6 連線. \n OBS + Youtube 直播要點: \n \n OBS 啟動後, 選擇利用 顯示卡擷取 進行電腦桌面操作影像擷取, 若在電腦輔助設計室直播可以關閉 audio 收音, 或者利用可以近距離收音的麥克風輸入 audio 操作說明. \n 登入 @gm 帳號並連接至 Youtube 後, 選擇 live stream 取得直播金鑰, 並將直播金鑰輸入 OBS. \n 當各項設定準備妥當後, 點擊 OBS 端的 開始串流 按鈕, 以便將桌面操作影片串流至 Youtube. \n 回到 Youtube live stream 頁面, 以滑鼠左鍵帶出 Copy video URL 後, 透過 gitter 發布直播網址. \n \n', 'tags': '', 'url': 'W12.html'}, {'title': 'W13', 'text': 'W13 第一段線上遠距課程教學內容影片  (有關如何利用  cmstemplate  建立 Gitlab 同名倉儲) \n W13 第二段線上遠距課程教學內容影片  (有關如何針對 github 與 gitlab 倉儲主分支分別為 main 與 master, 設定 remote add 同步倉儲與 pages 同步靜態網頁) \n W13 第三段線上遠距課程教學內容影片  (W13demo ( on github ,  on gitlab ) 採用 github main, gitlab master 主分支的處理流程) \n 上述操作過程所牽涉指令與內容: \n gitlab.com (gitlab 官方網站)\n\nlogin github.com (登入 github.com)\n\ngithub.com/mdecourse/cmstemplate (cmstemplate 所在網址）\n\ngithub.com/mdecourse/w13demo (w13demo 倉儲所在網址)\n\ngithub pages (Github 提供 WWW 伺服專有名稱)\n\nmdecourse.github.io (mdecourse github pages 網址)\n\nmdecourse.github.io/w13demo\n\ngit clone --recurse-submodules https://github.com/mdecourse/w13demo.git\n\ngit clone --recurse-submodules git@github.com:mdecourse/w13demo.git\n\ngithub pages <==> gitlab pages\n\nY:\\tmp\\w13demo>git remote add gitlab https://gitlab.com/mdecourse/w13demo.git\n\nY:\\tmp\\w13demo>git branch master\n\nY:\\tmp\\w13demo>git checkout master\n\ngit merge master (將 master 分支內容合併進來)\n\n \n 為因應校方公告: \n 「嚴重特殊傳染性肺炎」疫情課程彈性處理事項_遠距教學公告_0515D(中英版本).pdf \n 5月17日至5月30日全校所有課程改採遠距教學. \n 本課程將在 W13-W14 週採取同步線上模式上課, 請所有修課學員密切注意\xa0 https://gitter.im/mdecourse/wcmj2021  上之公告, 線上同步上課將採 OBS + Youtube 配合\xa0 https://meet.google.com/  直播方式進行, 請各學員屆時必須事先登入 github 帳號與 @gm 電子郵箱帳號, 以便在課程直播網站上留言討論. \n 同步直播課程進行過程將指定各組員針對課程內容進行 OBS + Youtube 直播操作, 負責直播學員必須即時將直播網址公布於  https://gitter.im/mdecourse/wcmj2021 , 以便與其他學員及老師進行互動. \n 課程同步直播時段將與上課時段相同, 每段直播中間的暫停時間將視實際情況決定. \n RoboDK 機械手臂 Pick and Place Python API 程式: \n 下載 RoboDK 5.2.2 可攜程式  ( 5.2.3 ) - 可用於工業機械手臂離線設計與模擬 \n 下載 CoppeliaSim 4.1.0 可攜程式  (協同產品設計實習使用套件) - 可用於機電資系統整合設計與模擬 \n 下載 Solvespace 3.0 stable  (開源3D 參數繪圖軟體) ( 3.0 stable ) - 可用於 3D 零組件繪圖 \n 下載 Range3 可攜程式  (開源 FEM 有限元素分析軟體) - 可用於零組件強度與變形分析 \n 已知 RoboDK 可以透過外部 Python API 程式執行官方  Pick and Place 範例 : \n 完整的  Pick and Place 檔案下載 \n 使用者開啟 Pick and Place 專案檔案後, Python 以 pip install robodk 後, 可以開啟下列控制程式, 逐一由機械手臂將球從 Table1 取放至 Table2, 圓球排列方式採  Square Pyramid . 使用者可精確送出各球座標位置, 導引機械手臂取放圓球. 操作過程如下: \n \n 控制程式如下: \n # KMOLab Portable RoboDK pick and place\nfrom robolink import *    # API to communicate with robodk\nfrom robodk import *      # robodk robotics toolbox\n\n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n\n#----------------------------------------------\n# Function definitions\n\ndef box_calc(BALLS_SIDE=4, BALLS_MAX=None):\n    """Calculate a list of points (ball center) as if the balls were stored in a box"""\n    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3\n    xyz_list = []\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE):\n            for j in range(BALLS_SIDE):\n                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]\n                if len(xyz_list) >= BALLS_MAX:\n                    return xyz_list\n    return xyz_list\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n\ndef balls_setup(frame, positions):\n    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""\n    nballs = len(positions)\n    step = 1.0/(nballs - 1)\n    for i in range(nballs):\n        newball = frame.Paste()\n        newball.setName(\'ball \' + str(i)) #set item name\n        newball.setPose(transl(positions[i])) #set item position with respect to parent\n        newball.setVisible(True, False) #make item visible but hide the reference frame\n        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color\n\ndef cleanup_balls(parentnodes):\n    """Delete all child items whose name starts with \\"ball\\", from the provided list of parent items."""\n    todelete = []\n    for item in parentnodes:\n        todelete = todelete + item.Childs()\n\n    for item in todelete:\n        if item.Name().startswith(\'ball\'):\n            item.Delete()\n\ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n        \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n\n\n#----------------------------------------------------------\n# The program starts here:\n\n# Any interaction with RoboDK must be done through RDK:\nRDK = Robolink(robodk_path="C:/robodk/bin/RoboDK.exe", robodk_ip=\'192.168.19.222\')\n\n# Turn off automatic rendering (faster)\nRDK.Render(False)\n\n#RDK.Set_Simulation_Speed(500); # set the simulation speed\n\n# Gather required items from the station tree\nrobot = RDK.Item(\'Fanuc M-710iC/50\')\nrobot_tools = robot.Childs()\n#robottool = RDK.Item(\'MainTool\')\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\n# Copy a ball as an object (same as CTRL+C)\nballref = RDK.Item(\'reference ball\')\nballref.Copy()\n\n# Run a pre-defined station program (in RoboDK) to replace the two tables\nprog_reset = RDK.Item(\'Replace objects\')\nprog_reset.RunProgram()\n\n# Call custom procedure to remove old objects\ncleanup_balls([frame1, frame2])\n\n# Make a list of positions to place the objects\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Programmatically place the objects with a custom-made procedure\nballs_setup(frame1, frame1_list)\n\n# Delete previously generated tools\nfor tool in robot_tools:\n    if tool.Name().startswith(\'TCP\'):\n        tool.Delete()\n        \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n# Turn on automatic rendering\nRDK.Render(True)\n\n# Move balls    \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame 1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame 2 and place the tool balls into table 2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n        \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n \n 今將上述範例中的 Robot, Tool, Table 與 ball 取出後, 可以完全利用外部 Python 程式重建機械手臂 Pick and Place 模擬, 過程如下: \n \n 上述模擬過程所使用的程式如下 ( pick and place final 專案下載 ): \n from robolink import *\nfrom robodk import *\n \nimport os\n \ndir_path = os.path.dirname(os.path.realpath(__file__))\nprint(dir_path)\n# Calculate pyramid coordinate\n \n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n \ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    #BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n     \ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n         \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n \n# Make a list of positions to place the objects\nballs_list = pyramid_calc(4)\n \n#print(len(frame1_list))\n# 4*4 = 16\n# 3*3 = 9\n# 2*2 = 4\n# 1+4+9+16 = 30\n \n# height 50*sqrt(2)\n\'\'\'\n[\n \n[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], \n \n[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], \n \n[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], \n \n[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], \n \n \n[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], \n \n[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], \n \n[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], \n \n \n[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], \n \n[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], \n \n \n[200.0, 200.0, 262.13203435596427]\n \n]\n \n\'\'\'\n# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py\n# robodk_path variable to specify location of RoboDK.exe\n# under Ubuntu can not use "-NEWINSTANCE"\n\'\'\'\nstart_robodk.sh content\nLD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"\nexport LD_LIBRARY_PATH\n/home/yen/RoboDK/bin/RoboDK\n\'\'\'\nRDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])\n# Add robot and the accompanied Base coordinate\nprint(dir_path + \'/Fanuc-M-710iC-50.robot\')\n# relative directory or absolute directory will work for AddFile under Ubuntu\n#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")\nrobot = RDK.AddFile(\'Fanuc-M-710iC-50.robot\')\n# Get the default robot base frame\nrobot_frame = RDK.Item(\'Fanuc M-710iC/50 Base\')\n# Move the base frame to the origin\nrobot_frame.setPose(transl(0,0,0))\n \n# Add a tool to an existing robot:\ntool = RDK.AddFile(dir_path + \'/MainTool.tool\', robot)\n \n# Add table 1\ntable1_frame = RDK.AddFrame(\'Table 1\')\ntable1_frame.setPose(transl(807.766544,-963.699898,41.478944))\ntable1_stl = RDK.AddFile(dir_path + \'/Table.stl\', table1_frame)\n \n# Add table 2\ntable2_frame = RDK.AddFrame(\'Table 2\')\ntable2_frame.setPose(transl(926.465508,337.151529,94.871928))\ntable2_stl = RDK.AddFile(dir_path + \'/Table.stl\', table2_frame)\n      \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n \nTCP_0 = TCP_list[0]\n \n# Turn on automatic rendering\nRDK.Render(True)\n \n# Add balls\n# create a list with 30 elements\nballs = [None for _ in range(30)]\nlayer = [16, 9, 4, 1]\ncount = 0\nfor i in range(len(balls_list)):\n    # transl(balls_list)\n    balls[i] = RDK.AddFile(\'./ball.stl\', table1_frame)\n    balls[i].setPose(transl(balls_list[i]))\n    count = count + 1\n    if count <= 16:\n        balls[i].setColor([1, 0, 0])\n    elif count > 16 and count <= 25:\n        balls[i].setColor([0, 1, 0])\n    elif count > 25 and count <=29:\n        balls[i].setColor([1, 1, 0])\n    else:\n        balls[i].setColor([0, 0, 1])\n \n# Make a list of positions to place the objects\n# ball_list is the same as frame1_list\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n \n# Move balls \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\n \ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n \n# frame1 is the same as table1_frame\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n \nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n \n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n \n    # grab ntake balls from frame1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1       \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n  \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame2 and place the tool balls into table2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1       \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n \n    robot.MoveJ(target_app_frame)\n \n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])', 'tags': '', 'url': 'W13.html'}, {'title': 'W14-W16', 'text': 'W14 第一段線上教學影片 \n W14 第二段線上教學影片  (在 Github 建立 w14demo 倉儲,\xa0 然後設法透過 SSH 將倉儲內容同步至 Gitlab) \n Gitlab 為了防止使用者濫用 CI/CD 服務進行挖礦, 因此 2021/5/17 之後建立帳號者, 若要使用 CI/CD 服務, 必須提供信用卡資料, 因此先前將 CMSiMDE Github Pages 靜態網頁同步至 Gitlab Pages 的方法, 已經不再適用. \n W15 線上課程教學影片  (說明如何將 Github wcmj2021 倉儲同步至 gogs 主機) \n \n 1. 利用 Ethercalc 表單取各組學員學號與 Github 帳號 \n 修改  https://raw.githubusercontent.com/mdecourse/cd2021/main/downloads/stage3/stage3_gen_html.py \xa0 對照  https://raw.githubusercontent.com/mdecourse/cd2021/main/downloads/stage3/stage3_2a.txt  建立分組 html, 以方便連結各組員的倉儲與網站. \n 2. 請每一組於 W15 上課之前根據  http://mde.tw/wcm2021/content/W11.html  中之說明, 討論如何利用組員的連外網路, 討論如何建立一台具 X-Window 功能的 Ubuntu 伺服器, 以便在此一虛擬主機上配置各組的 CMSiMDE 靜態與動態網頁. \n 3. 請各組在上述分組 Ubuntu 主機上安裝 RoboDK (Windows 端 X server 可使用  Xming ), 並且讓各組員可以在線上串流過程中 (Google Meet 或 OBS + Youtube), 跨網路利用  RoboDK 頁面 上的 Python Remote API 程式, 遠端操控 FANUC 六軸機械手臂的圓球取放流程. \n 4. 以上各組在討論與任務內容執行過程, 必須全程錄影, 並將影片設為可公開連結或觀看後, 放入各組的期末分組網站中, 且各組員必須在各自的倉儲帳號下, 分別建立一個各組的分組同步倉儲與同步分組網站. \n 5. 請各學員在 Gitlab 利用 SSH 協定, 建立個人在 Github 課程倉儲的同步倉儲, 並利用  Gitlab Pages  呈現個人與分組同步網站. \n W15 議題: \n 請各組學員在 W15 課程時間內, 號召組員進行一段 30 分種的線上會議 (採 Google Meet 或 OBS + Youtube) 並全程錄影, 整理至今各組員所完成的課程內容項目與所遭遇問題, 完成後請將討論議題與結果存入各分組網站後, 將個人課程成果與分組網站上的 W15 頁面連結與影片連結登錄至  W13-W14 任務執行回報區 . \n W16: \n W16 第一段線上教學影片 \n W16 第二段線上教學影片 \n W16 第三段線上教學影片 \n 第一台靜態網頁主機: \n 利用 heroku6 At mde 建立 (1/5) \n Github 倉儲:  https://github.com/heroku6/wcmw16.git \xa0 \n 下載可攜 heroku cli 之後, 設定可攜程式啟動之命令搜尋路徑, 讓 heroku 可以在任何隨身系統的目錄中執行. \n heroku login 後, y:\\home 目錄中會新增一個代表登入帳號身分的 _netrc 檔案. \n 以下則利用倉儲中的 index.php 讓 cmstemplate 靜態網頁可以在\xa0 http://wcmw16.herokuapp.com/ \xa0中伺服. 且此一倉儲, 可以在\xa0 heroku login 成功登入授權者帳號後, 以\xa0git clone --recurse-submodules\xa0 https://git.heroku.com/wcmw16.git \xa0 取下倉儲檔案. \n 第二台動態網頁主機: \n 利用 heroku6 At mde 建立 (2/5) \n Github 倉儲:  https://github.com/heroku6/wcmapp.git \xa0 \n 主機建立流程均如上列第三部影片中所示, 唯一的差別是 Procfile 必須設定為: \n web: gunicorn --chdir cmsimde flaskapp:app \n 表示要令 gunicorn 進入 cmsimde 目錄後, 再透過 flaskapp.py 檔案中的 app 物件變數啟動網站. 所完成的網站:\xa0 https://wcmapp.herokuapp.com/ , 但由於不具備 persistent 儲存檔案功能, 此動態網站只能展示動態網頁的基本功能, 內容無法修改存檔.\xa0此一倉儲, 可以在\xa0 heroku login 成功登入授權者帳號後, 以\xa0git clone --recurse-submodules\xa0 https://git.heroku.com/wcmapp.git \xa0取下倉儲檔案. \n \n \n', 'tags': '', 'url': 'W14-W16.html'}, {'title': '分組專題', 'text': '分組專題影片回報與討論區: \n https://github.com/mdecourse/wcmj2021/discussions/10 \n 分組專題題目: \n \n 實體 Windows 10 64 位元電腦安裝與配置應用 (Ram 16 GB 電腦, 可以在其中安裝 Virtualbox 再安裝其他操作系統) \n 實體 Ubuntu 20.04 Desktop 電腦安裝與配置應用 (Ram 8GB, 可以利用 free -m 查詢記憶體容量) \n 實體 Ubuntu 20.04 Server 電腦安裝與配置應用 (Ram 8GB) \n 虛擬 Windows 10 64 位元電腦安裝與配置應用 (若 CPU 夠快並且 Ram 夠大, 可以透過  Nested Virtualization  技術, 在虛擬主機中再安裝配置虛擬主機) \n 虛擬 Ubuntu 20.04 Desktop 電腦安裝與配置應用 \n 虛擬 Ubuntu 20.04 Server 電腦安裝與配置應用 \n 參數繪圖軟體安裝 (Solidworks, NX 與 Inventor) \n \n Windows 10 操作系統 iso 下載 - 請登入\xa0 https://software.nfu.edu.tw/  下載 (或在校園網路 直接下載 Win10 64位元 1909.iso ,  windows_kms.bat , 目前只能在 IPv4 環境下每半年認證一次) \n 下載  直接下載 Win10 64位元 1909.iso  後, 必須利用  https://rufus.ie/en_US/  將資料轉存入至少 8GB 以上的隨身碟後進行安裝, 或以 Blu-ray (25GB) 或雙面 DVD Double Layer (8.5GB) 進行燒錄後安裝. \n MS Office 2016 中文版.iso ,  office_kms.bat \n Nod 64 位元.zip \n Matlab2020b 64 位元.zip  ( Matlab 安裝方法.zip ) \n AutoDesk.iso  ( AutoDesk 安裝說明.pdf ,  IPv6 認證位址.pdf ) \n Ubuntu 20.04 Desktop iso 下載 \n Ubuntu 20.04 Server iso 下載 \n Ubuntu 操作系統參考文件:  https://help.ubuntu.com/lts/ubuntu-help/index.html \n CMSiMDE 部署:  https://mdecourse.blogspot.com/2020/05/cmsimde_64.html \n Fossil SCM on Ubuntu: \n https://mdecourse.blogspot.com/2021/02/fossil-scm-on-ubuntu.html  (安裝) \n https://mdecourse.blogspot.com/2021/02/fossil-scm.html  (使用案例) \n https://mdecourse.blogspot.com/2021/02/fossil-scm-github.html  (與 Github 整合) \n Virtualbox 軟體下載 \n 了解  https://www.virtualbox.org/manual/ch06.html  (NAT, Host Only 與 Bridged 網路的配置與應用) \n 每一台 Virtualbox 虛擬主機可以 配置 36 片虛擬網路卡 \n 每個虛擬主機硬碟檔案都有獨特的  UUID  (通用唯一辨識碼), 使用者可以利用指令變更硬碟檔案的辨識編號. \n Virtualbox 虛擬主機設定: \n https://mdecourse.blogspot.com/2020/05/virtualbox-ubuntu.html \n CMSiMDE 部署:  https://mdecourse.blogspot.com/2020/05/cmsimde_64.html \n Solidworks 安裝 dvd 下載 \n NX 安裝 dvd 下載 \n Inventor 安裝 dvd 下載 \n Fossil SCM 軟體下載  (for 自行在實體或虛擬 Ubuntu 操作系統中配置分散式版次管理系統) \n 了解 Google API 程式架構 (for Pelican Blog 與 Blogger 網誌內容同步) - 從  https://console.developers.google.com  登入. \n Pelican 與 Blogger 網誌同步: \n https://mdecourse.blogspot.com/2020/05/pelican-blogger_21.html \n https://mdecourse.blogspot.com/2021/02/pelican-blogger.html \n 各實體或虛擬 Ubuntu 操作系統中也可以 自行配置 Ethercalc 網際環境  (即自行配置一套  https://ethercalc.net/ )', 'tags': '', 'url': '分組專題.html'}, {'title': '實體 Win10 安裝', 'text': '實體 Windows 10 64 位元電腦安裝與配置應用 (Ram 16 GB 電腦, 可以在其中安裝 Virtualbox 再安裝其他操作系統) \n From  https://www.freecodecamp.org/news/uefi-vs-bios/ \n BIOS stands for Basic Input/Output System which is the firmware for the boot procedure. It is stored on an EPROM (Erasable Programmable Read-Only Memory), allowing the manufacturer to push out updates easily. \n UEFI stands for Unified Extensible Firmware Interface. It does the same job as a BIOS, but with one basic difference: it stores all data about initialization and startup in an .efi file, instead of storing it on the firmware. This .efi file is stored on a special partition called EFI System Partition (ESP) on the hard disk. This ESP partition also contains the bootloader. \n UEFI was designed to overcome many limitations of the old BIOS, including: \n \n UEFI supports  drive sizes upto 9 zettabytes (=9x1000^^3 terra bytes ) , whereas BIOS only supports 2.2 terabytes. \n UEFI provides  faster boot time . \n UEFI has  discrete driver support , while BIOS has drive support stored in its ROM, so updating BIOS firmware is a bit difficult. \n UEFI offers security like " Secure Boot ", which prevents the computer from booting from unauthorized/unsigned applications. This helps in preventing rootkits, but also hampers dual-booting, as it treats other OS as unsigned applications. Currently, only Windows and Ubuntu are signed OS. \n UEFI runs in 32bit or 64bit mode, whereas BIOS runs in 16bit mode. So UEFI\xa0 is able to provide a  GUI  (navigation with mouse) as opposed to BIOS which allows navigation only using the keyboard. \n \n 完成 Windows 10 安裝後： \n \n 自行配置能夠用來啟動  cmstermplate  網站的 Python 系統 \n 自行安裝  Git  並配置  SciTE,  令其可以執行版次管理並在  SciTE  環境中解譯 Python3 程式. \n 自行設定  SSH  讓各組員可以利用不同帳號登入 Windows 後進行靜態網頁的 Github 倉儲改版 (或者, 採隨身碟設定, 讓各組員可以透過隨身碟共用 Windows 10 操作系統). \n 自行安裝  RoboDK  與  RoKSim , 利用  SciTE  設定執行  Pick and Place Python  操控 RoboDK 範例. \n 從  http://mde.tw/cad2020/content/HW3.html  中的 Solidworks 機械手臂零組件中, 了解如何自行設定六軸機械手臂的座標轉換矩陣, 如何透過正運動學 ( Forward Kinematics)  與逆運動學 ( Inverse Kinematics ), 控制機械臂端點的工具, 完成各項自動化製造程序所需的任務. \n \n 參考資料： \n 建立 Windows 10 安裝 USB 隨身碟 \n Windows 10 安裝教學 \n UEFI 與 BIOS 差異 \n 校園軟體與電腦管理', 'tags': '', 'url': '實體 Win10 安裝.html'}, {'title': '實體 Ubuntu Server 安裝', 'text': '在系上主幹網路安裝實體 Ubuntu Server 時, 一般建議將 IPv4 網路關閉, 使用 DHCP IPv6 網路連線進行安裝, 並且加裝 OpenSSH. 完成 Server 安裝後: \n sudo apt update \n sudo apt upgrade \n sudo apt autoremove \n 之後若希望安裝 Desktop, 使用 sudo apt install ubuntu-desktop \n https://ubuntu.com/tutorials/install-ubuntu-server \n Ubuntu Server 安裝 \n https://2019wcm.blogspot.com/2019/05/wcm-week-15.html  (Ubuntu Server setup) \n 完成 Ubuntu 20.04 Server 安裝後, 能否進一步設定 Fossil SCM 環境, 讓 cmstemplate 靜態網站能夠透過 Ubuntu 操作系統顯示網頁? 如  https://fossil.kmol.info . \n 實體 Ubuntu Desktop 安裝 \n https://ubuntu.com/tutorials/install-ubuntu-desktop \n 安裝 Ubuntu 20.04 Desktop 之後, 能否在桌面設定與 Windows 10 維護 Github 倉儲與靜態網站的各項功能? \n', 'tags': '', 'url': '實體 Ubuntu Server 安裝.html'}, {'title': 'Virtualbox 安裝操作系統', 'text': '更改虛擬檔案的 uuid: \n 在 Virtualbox 安裝的 vdi 或 vmdk 當複製後在同一套 Virtualbox 下使用時必須擁有獨一的 uuid, 因此複製虛擬檔案後, 可以利用下列指令更改 uuid. \n "c:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe" internalcommands sethduuid robodk.vmdk \n 安裝虛擬主機參考資料: \n https://mdecourse.blogspot.com/2020/05/virtualbox-ubuntu.html \n Virtualbox: \n https://www.virtualbox.org/manual/ch01.html \n https://www.nakivo.com/blog/use-virtualbox-quick-overview/ \n YAML:  https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started/ \n Netplan:  https://linuxconfig.org/netplan-network-configuration-tutorial-for-beginners \n Netplan Examples:  https://netplan.io/examples/ \n Windows 套件安裝 \n MS Office \n Visual Studio \n Matlab \n Solidworks \n Autodesk Inventor \n NX \n Ubuntu 套件安裝 \n 舊電腦處理: \n http://project.mde.tw/blog/cadlab-jiu-dian-nao-de-chu-li.html \n', 'tags': '', 'url': 'Virtualbox 安裝操作系統.html'}, {'title': 'RoboDK', 'text': '安裝 Windows 10 後, 可從  robodk522_portable.7z  下載可攜 RoboDK free trial 套件 (無法存檔), 執行下列實習: \n \n 近端 Python API 操控 \n 跨區域網路 Python remote API 操控 \n 網際 Python remote API 操控 \n \n 近端 Python API 操控 \n 由於 RoboDK 提供  Python API 控制模組 , 一旦可攜 Python 程式套件安裝 robodk 模組後, 就可以利用 Python 程式控制各式工業級六軸機械手臂. \n 安裝 robodk 模組 \n pip install robodk \n 開啟 RoboDK \n 解開  robodk522_portable.7z  壓縮檔案後, 執行 bin/RoboDK.exe 即可執行 RoboDK free trial 版本. \n 下載 pick and place rdk 專案檔 \n 從  https://github.com/mdecourse/wcmj2021/blob/main/downloads/robodk/pick_and_place/pick_and_place_with_python.rdk  下載範例專案檔, 存為 y:\\tmp\\pick_and_place.rdk 後, 以 RoboDK 開啟專案檔. \n 下載 pick and place python 程式檔 \n 從  https://raw.githubusercontent.com/mdecourse/wcmj2021/main/downloads/robodk/pick_and_place/pick_and_place.py  另存新檔為 y:\\tmp\\pick_and_place.py 後, 以可攜系統的 SciTE 編輯器開啟. \n 由於 RoboDK 的 API 伺服器內建於 localhost, 因此只要以 Tools-Go 執行 pick_and_place.py 即可控制近端的 pick_and_place.rdk 專案檔案中的機械手臂. \n \n 延伸練習: \n https://robodk.com/doc/en/Basic-Guide.html \n https://robodk.com/doc/en/RoboDK-API.html#RoboDKAPI \n https://robodk.com/doc/en/PythonAPI/robolink.html#robolink.Robolink.AddFile \n https://github.com/RoboDK/RoboDK-API/tree/master/Python \n https://robodk.com/doc/en/Robot-Programs-Simulation-event.html \n http://a.kmol.info:88/Robot_files.7z \n 以下範例執行時透過 Replace Objects 程式段讓 Table 互換, 假如不呼叫執行此一 Replace Objects, 能否讓 Robot 將 Table 2 的球放回 Table 1? \n # KMOLab Portable RoboDK pick and place\nfrom robolink import *    # API to communicate with robodk\nfrom robodk import *      # robodk robotics toolbox\n\n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\n# Tool Center Point (TCP)\n\nnTCPs = 6           # number of TCP\'s in the tool\n\n#----------------------------------------------\n# Function definitions\n\ndef box_calc(BALLS_SIDE=4, BALLS_MAX=None):\n    """Calculate a list of points (ball center) as if the balls were stored in a box"""\n    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3\n    # xyz_list 資料型別設定為數列 (List)\n    xyz_list = []\n    # 建立三層 for 迴圈\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE):\n            for j in range(BALLS_SIDE):\n                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]\n                if len(xyz_list) >= BALLS_MAX:\n                    return xyz_list\n    return xyz_list\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n\ndef balls_setup(frame, positions):\n    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""\n    nballs = len(positions)\n    step = 1.0/(nballs - 1)\n    for i in range(nballs):\n        newball = frame.Paste()\n        newball.setName(\'ball \' + str(i)) #set item name\n        newball.setPose(transl(positions[i])) #set item position with respect to parent\n        newball.setVisible(True, False) #make item visible but hide the reference frame\n        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color\n\ndef cleanup_balls(parentnodes):\n    """Delete all child items whose name starts with \\"ball\\", from the provided list of parent items."""\n    todelete = []\n    for item in parentnodes:\n        todelete = todelete + item.Childs()\n\n    for item in todelete:\n        if item.Name().startswith(\'ball\'):\n            item.Delete()\n\ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n        \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n\n\n#----------------------------------------------------------\n# The program starts here:\n\n# Any interaction with RoboDK must be done through RDK:\nRDK = Robolink()\n\n# Turn off automatic rendering (faster)\nRDK.Render(False)\n\n#RDK.Set_Simulation_Speed(500); # set the simulation speed\n\n# Gather required items from the station tree\nrobot = RDK.Item(\'Fanuc M-710iC/50\')\nrobot_tools = robot.Childs()\n#robottool = RDK.Item(\'MainTool\')\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\n# Copy a ball as an object (same as CTRL+C)\nballref = RDK.Item(\'reference ball\')\nballref.Copy()\n\n# Run a pre-defined station program (in RoboDK) to replace the two tables\nprog_reset = RDK.Item(\'Replace objects\')\nprog_reset.RunProgram()\n\n# Call custom procedure to remove old objects\ncleanup_balls([frame1, frame2])\n\n# Make a list of positions to place the objects\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Programmatically place the objects with a custom-made procedure\nballs_setup(frame1, frame1_list)\n\n# Delete previously generated tools\nfor tool in robot_tools:\n    if tool.Name().startswith(\'TCP\'):\n        tool.Delete()\n        \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n# Turn on automatic rendering\nRDK.Render(True)\n\n# Move balls    \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame 1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame 2 and place the tool balls into table 2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n        \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n \n 假如希望透過 Python API 建立 RoboDK station (因為 free trial 版本無法存檔), 可以使用  https://github.com/mdecourse/wcmj2021/tree/main/downloads/robodk/pick_and_place_kmol_mac  目錄中的物件與程式, 範例程式如下: \n from robolink import *\nfrom robodk import *\n\n# Calculate pyramid coordinate\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n    \n\n# Make a list of positions to place the objects\nballs_list = pyramid_calc(4)\n\n#print(len(frame1_list))\n# 4*4 = 16\n# 3*3 = 9\n# 2*2 = 4\n# 1+4+9+16 = 30\n\n# height 50*sqrt(2)\n\'\'\'\n[\n\n[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], \n\n[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], \n\n[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], \n\n[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], \n\n\n[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], \n\n[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], \n\n[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], \n\n\n[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], \n\n[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], \n\n\n[200.0, 200.0, 262.13203435596427]\n\n]\n\n\'\'\'\n# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py\n# robodk_path variable to specify location of RoboDK.exe\nRDK = Robolink(args=["-NEWINSTANCE", "-SKIPINI", "-EXIT_LAST_COM"])\n\n# Add robot and the accompanied Base coordinate\nrobot = RDK.AddFile(\'Fanuc-M-710iC-50.robot\')\n# Get the default robot base frame\nrobot_frame = RDK.Item(\'Fanuc M-710iC/50 Base\')\n# Move the base frame to the origin\nrobot_frame.setPose(transl(0,0,0))\n\n# Add a tool to an existing robot:\ntool = RDK.AddFile(\'MainTool.tool\', robot)\n\n# Add table 1\ntable1_frame = RDK.AddFrame(\'Table 1\')\ntable1_frame.setPose(transl(807.766544,-963.699898,41.478944))\ntable1_stl = RDK.AddFile(\'Table.stl\', table1_frame)\n\n# Add table 2\ntable2_frame = RDK.AddFrame(\'Table 2\')\ntable2_frame.setPose(transl(926.465508,337.151529,94.871928))\ntable2_stl = RDK.AddFile(\'Table.stl\', table2_frame)\n\n# Add balls\n# create a list with 30 elements\nballs = [None for _ in range(30)]\nlayer = [16, 9, 4, 1]\ncount = 0\nfor i in range(len(balls_list)):\n    # transl(balls_list)\n    balls[i] = RDK.AddFile(\'ball.stl\', table2_frame)\n    balls[i].setPose(transl(balls_list[i]))\n    count = count + 1\n    if count <= 16:\n        balls[i].setColor([1, 0, 0])\n    elif count > 16 and count <= 25:\n        balls[i].setColor([0, 1, 0])\n    elif count > 25 and count <=29:\n        balls[i].setColor([1, 1, 0])\n    else:\n        balls[i].setColor([0, 0, 1])\n \n 所完成的 station 如下: \n \n \n', 'tags': '', 'url': 'RoboDK.html'}, {'title': 'IYEP', 'text': 'Improve Your English Proficiency \n http://mde.tw/cad2020/content/解救菜英文.html', 'tags': '', 'url': 'IYEP.html'}, {'title': 'Mac', 'text': '在一般的認知上,\xa0 Mac 電腦並不太適合機械相關領域人員使用, 因為 Solidworks 與 Inventor 都只提供 Windows 版本, 但是隨著網際 CAD 系統 ( https://onshape.com ) 的發展越發成熟, 只要 Mac 電腦的記憶體與顯示卡的配備夠強, 機械設計工程師仍然可以跨 Windows 與 Mac (或其他 Unix 操作系統) 進行各項工作. \n 以下則是使用 USB 隨身碟在 Windows 與 Mac Air 交叉使用的注意事項: \n Mac Air 操作: \n Command + Shift + . 隱藏檔案 toggle \n Python 分為 python 與 python3, 操作 CMSiMDE 網際內容管理系統時, 必須使用 python3. \n USB 隨身碟在 Mac 中位於 /Volumes 目錄下. \n 與 Git SSH 對應的 OpenSSH private key 位於 ~/.ssh/id_rsa \n RoboDK \n RoboDK 與 SciTE 在 Mac Air 的執行畫面: \n', 'tags': '', 'url': 'Mac.html'}, {'title': 'Web Site', 'text': '利用 Github 與 Gitlab 倉儲建立個人網頁 \n 何謂網際內容管理? \n Web-based Content Management \n Content? \n 3D 零組件 \n https://www.onshape.com \n 英文學習紀錄 \n 數學學習紀錄 \n 專業課程學習紀錄 \n Video \n https://github.com/ShareX/ShareX \n https://www.blender.org/ \n Audio \n https://www.audacityteam.org/ \n Images \n https://www.gimp.org/ \n https://inkscape.org/ \n Animation \n Github 是甚麼? \n Gitlab 又是甚麼? \n 自行在 Ubuntu 操作系統上安裝 Gitlab? \n Ubuntu 操作系統? \n 實體系統 \n 虛擬系統 \n Virtualbox', 'tags': '', 'url': 'Web Site.html'}, {'title': 'Google', 'text': '有關 Google 的發展歷史:  https://en.wikipedia.org/wiki/Google  請各組仔細閱讀這份資料後, 將認為重點的資料放入各學員的 blogger 網誌以及個人網站中. \n', 'tags': '', 'url': 'Google.html'}, {'title': 'Oauth2', 'text': 'https://github.com/zquestz/omniauth-google-oauth2 \n https://github.com/thephpleague/oauth2-google \n', 'tags': '', 'url': 'Oauth2.html'}, {'title': 'Calendar API', 'text': 'https://github.com/kuzmoyev/google-calendar-simple-api \n', 'tags': '', 'url': 'Calendar API.html'}, {'title': 'Drive API', 'text': 'https://github.com/iterative/PyDrive2', 'tags': '', 'url': 'Drive API.html'}]};